<!-- <!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Orbit Simulation with Polar Graph and Theta</title>
<style>
    body {
        margin: 0;
        overflow: hidden;
        background: black;
        color: #fff;
        font-family: sans-serif;
    }

    #controls {
        position: absolute;
        top: 20px;
        left: 20px;
        width: 300px;
        background: rgba(255, 255, 255, 0.05); /* very subtle transparent bg */
        padding: 15px;
        border-radius: 12px;
        border: 1px solid rgba(255,255,255,0.2);
        backdrop-filter: blur(5px); /* subtle blur behind */
        box-shadow: 0 8px 20px rgba(0,0,0,0.3);
    }

    #controls label {
        display: block;
        margin-top: 12px;
        font-size: 16px;
    }

    #controls input[type=range] {
        width: 100%;
        height: 16px;
        margin-top: 4px;
        accent-color: #00ffff;
    }

    #params {
        margin-top: 15px;
        font-size: 14px;
        line-height: 1.5;
        padding: 8px;
        background: rgba(255,255,255,0.05);
        border-radius: 8px;
        border: 1px solid rgba(255,255,255,0.15);
    }

    #thetaGraph {
        width: 100%;
        height: 200px;
        border: 1px solid #00ffff;
        margin-top: 15px;
        display: block;
        border-radius: 8px;
        background: rgba(255,255,255,0.05);
    }

    #thetaValue {
        margin-top: 8px;
        font-size: 14px;
        text-align: center;
        color: #00ffff;
    }

    /* Optional: nice scrollbar for the panel if needed */
    #controls::-webkit-scrollbar {
        width: 6px;
    }
    #controls::-webkit-scrollbar-thumb {
        background-color: rgba(0,255,255,0.5);
        border-radius: 3px;
    }
</style>

</head>
<body>
<div id="controls">
    <label>Sun Mass (M) <span id="Mval"></span>
        <input type="range" id="Mslider" min="0" max="6" step="0.01" value="1">
    </label>
    <label>Earth Mass (m) <span id="mval"></span>
        <input type="range" id="mslider" min="0" max="6" step="0.01" value="1">
    </label>
    <label>Perihelion (rmin) <span id="rval"></span>
        <input type="range" id="rslider" min="0" max="6" step="0.01" value="1">
    </label>
    <label>Velocity (vo) <span id="vval"></span>
        <input type="range" id="vslider" min="0" max="6" step="0.01" value="1">
    </label>
    <div id="params">
        <strong>Orbit Parameters:</strong><br>
        e = <span id="eval"></span><br>
        a = <span id="aval"></span><br>
        b = <span id="bval"></span><br>
        h = <span id="hval"></span><br>
        ε = <span id="epsval"></span><br>
        Tangential Velocity = <span id="velval"></span> m/s<br>
        Orbital Period = <span id="periodval"></span> years<br>
        Theta (θ) = <span id="thetaval"></span>
    </div>
    <canvas id="thetaGraph" width="300" height="300"></canvas>
    <div id="thetaValue">Theta Value: 0 rad | 0°</div>
</div>

<script type="module">
import * as THREE from "https://cdn.skypack.dev/three@0.129.0";
import { OrbitControls } from "https://cdn.skypack.dev/three@0.129.0/examples/jsm/controls/OrbitControls.js";
import { CSS2DRenderer, CSS2DObject } from "https://cdn.skypack.dev/three@0.129.0/examples/jsm/renderers/CSS2DRenderer.js";
import { EffectComposer } from 'https://cdn.skypack.dev/three@0.129.0/examples/jsm/postprocessing/EffectComposer.js';
import { RenderPass } from 'https://cdn.skypack.dev/three@0.129.0/examples/jsm/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'https://cdn.skypack.dev/three@0.129.0/examples/jsm/postprocessing/UnrealBloomPass.js';

// === Three.js Scene ===
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(85, window.innerWidth/window.innerHeight, 0.1, 10000);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.05;
camera.position.z = 30;

// Constants
const original = {
    M: 1.98847e30,
    m: 5.97237e24,
    rmin: 1.47095e11,
    vo: 3.029195106e4,
    G: 6.67430e-11
};
const SCALE_FACTOR = 1e-10;

// DOM Elements
const sliders = { M: document.getElementById("Mslider"), m: document.getElementById("mslider"),
                  rmin: document.getElementById("rslider"), vo: document.getElementById("vslider") };
const labels = { M: document.getElementById("Mval"), m: document.getElementById("mval"),
                 rmin: document.getElementById("rval"), vo: document.getElementById("vval") };
const paramLabels = { e: document.getElementById("eval"), a: document.getElementById("aval"),
                      b: document.getElementById("bval"), h: document.getElementById("hval"),
                      eps: document.getElementById("epsval"), vel: document.getElementById("velval"),
                      period: document.getElementById("periodval"), theta: document.getElementById("thetaval") };
const thetaValueDiv = document.getElementById("thetaValue");

for (let key in sliders) {
    labels[key].innerText = sliders[key].value;
    sliders[key].addEventListener("input", () => {
        labels[key].innerText = sliders[key].value;
        updateOrbit();
    });
}

// Canvas for theta graph
const thetaCanvas = document.getElementById("thetaGraph");
const thetaCtx = thetaCanvas.getContext("2d");

// Sun
const textureLoader1 = new THREE.TextureLoader();
const fireTexture = textureLoader1.load('./sun.jpg');
fireTexture.wrapS = fireTexture.wrapT = THREE.RepeatWrapping;
// Sun Material
const sunMaterial = new THREE.MeshStandardMaterial({
  map: fireTexture,
  emissive: new THREE.Color(0xffaa00),
  emissiveMap: fireTexture,
  emissiveIntensity: 2
});
// Sun Mesh
const sunGeometry = new THREE.SphereGeometry(2, 18, 18);
const sun = new THREE.Mesh(sunGeometry, sunMaterial);
scene.add(sun);
const sunLight = new THREE.PointLight(0xffddaa, 10, 1000);
sunLight.position.copy(sun.position);
scene.add(sunLight);
const composer = new EffectComposer(renderer);
composer.addPass(new RenderPass(scene, camera));
composer.addPass(new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85));
 // Texture Loader
  const loader = new THREE.TextureLoader();
  const planetTexture = loader.load("./earth_day_4096.jpg"); // <-- change to your planet image

  // Planet Material & Mesh
  const planetMaterial = new THREE.MeshPhongMaterial({
    map: planetTexture,
          bumpMap: planetTexture,
  bumpScale: 0.05,
  roughness: 1,
  metalness: 0
    
  });
// Earth
const earth1 = new THREE.SphereGeometry(0.5,32,32);
 const earth = new THREE.Mesh(earth1,planetMaterial);
scene.add(earth);

// Velocity Arrow
const velocityArrow = new THREE.ArrowHelper(new THREE.Vector3(1,0,0), new THREE.Vector3(0,0,0), 2, 0xff0000);
scene.add(velocityArrow);

let orbitLine = null;
let orbitPoints = [];
let orbitTheta = 0;

// Orbit calculations
function computeOrbit(M, m, G, rmin, vo){
    const h = rmin * vo;
    const eps = 0.5 * vo * vo - (G * M) / rmin;
    const e = Math.sqrt(1 + (2 * eps * h*h)/(G*M*G*M));
    let a = (e<1)? -(G*M)/(2*eps) : Math.abs(G*M/(2*eps));
    if(e===1) a=h*h/(G*M);
    return {h, eps, e, a};
}

function createOrbit(a,e,numPoints=500){
    const points = [];
    if(e<1){
        const centerX=-a*e;
        const b=a*Math.sqrt(1-e*e);
        for(let i=0;i<=numPoints;i++){
            const theta=i/numPoints*2*Math.PI;
            const x=centerX+a*Math.cos(theta);
            const z=b*Math.sin(theta);
            points.push(new THREE.Vector3(x*SCALE_FACTOR,0,z*SCALE_FACTOR));
        }
    }else{
        const thetaMax = (e>=1)? Math.acos(-1/e)*0.95 : Math.PI*0.95;
        for(let i=0;i<=numPoints;i++){
            const theta=i/numPoints*2*thetaMax - thetaMax;
            const r = (e===1)? a/(1+e*Math.cos(theta)) : a*(e*e-1)/(1+e*Math.cos(theta));
            if(r>0){
                points.push(new THREE.Vector3(r*Math.cos(theta)*SCALE_FACTOR,0,r*Math.sin(theta)*SCALE_FACTOR));
            }
        }
    }
    return points;
}

function updateOrbit(){
    if(orbitLine) scene.remove(orbitLine);
    const Mval=original.M*parseFloat(sliders.M.value);
    const mval=original.m*parseFloat(sliders.m.value);
    const rval=original.rmin*parseFloat(sliders.rmin.value);
    const vval=original.vo*parseFloat(sliders.vo.value);
    const orbit=computeOrbit(Mval,mval,original.G,rval,vval);

    let b=(orbit.e<1)? orbit.a*Math.sqrt(1-orbit.e*orbit.e) :
          (orbit.e>1)? orbit.a*Math.sqrt(orbit.e*orbit.e-1) : orbit.a;

    // Orbital period in years
    let period="Infinity";
    if(orbit.e<1){
        period = (2*Math.PI*Math.sqrt(Math.pow(orbit.a,3)/(original.G*Mval)))/(60*60*24*365.25);
        period = period.toFixed(3);
    }

    paramLabels.e.innerText=orbit.e.toFixed(5);
    paramLabels.a.innerText=orbit.a.toExponential(5);
    paramLabels.b.innerText=(typeof b==="number")? b.toExponential(5) : b;
    paramLabels.h.innerText=orbit.h.toExponential(5);
    paramLabels.eps.innerText=orbit.eps.toExponential(5);
    paramLabels.period.innerText=period;

    orbitPoints=createOrbit(orbit.a,orbit.e,500);
    orbitLine=new THREE.Line(new THREE.BufferGeometry().setFromPoints(orbitPoints),
                             new THREE.LineBasicMaterial({color:0x00FFFF}));
    scene.add(orbitLine);
    orbitTheta=0;
}
// / Light
const pointLight = new THREE.PointLight(0xffffff, 2, 2000);
pointLight.position.set(50, 50, 50);
scene.add(pointLight);
scene.add(new THREE.AmbientLight(0x333333));

// ------------ Function: Create Sphere with Surface Particles ------------
function createSphereWithParticles(radius, numParticles, opacity, color, position) {
  const particlesGeometry = new THREE.BufferGeometry();
  const positions = [];

  for (let i = 0; i < numParticles; i++) {
    // Random direction on a sphere (normalized vector)
    const theta = Math.random() * Math.PI * 2;  // azimuth
    const phi = Math.acos(2 * Math.random() - 1); // polar angle
    const x = radius * Math.sin(phi) * Math.cos(theta);
    const y = radius * Math.sin(phi) * Math.sin(theta);
    const z = radius * Math.cos(phi);
    positions.push(x, y, z);
  }

  particlesGeometry.setAttribute(
    "position",
    new THREE.Float32BufferAttribute(positions, 3)
  );

  const particlesMaterial = new THREE.PointsMaterial({
    color: color,
    size: 0.3,
    transparent: true,
    opacity: opacity,
    blending: THREE.AdditiveBlending
  });

  const particleSystem = new THREE.Points(particlesGeometry, particlesMaterial);
  particleSystem.position.copy(position);
  scene.add(particleSystem);

  return particleSystem;
}

// ------------ Create Multiple Spheres with Particles ------------
const spheres = [];
spheres.push(createSphereWithParticles(109000, 1000, 0.8, 0xff0f00, new THREE.Vector3(-50, 0, 0)));
spheres.push(createSphereWithParticles(107000, 1000, 0.8, 0xf00f00, new THREE.Vector3(-50, 0, 0)));
spheres.push(createSphereWithParticles(6000, 1000, 0.8, 0xefff00, new THREE.Vector3(-50, 0, 0)));
spheres.push(createSphereWithParticles(10500, 1000, 0.8, 0xfeef00, new THREE.Vector3(-50, 0, 0)));
spheres.push(createSphereWithParticles(100000, 1000, 0.8, 0xffef00, new THREE.Vector3(-50, 0, 0)));
spheres.push(createSphereWithParticles(100300, 1000, 0.8, 0xff0000, new THREE.Vector3(-50, 0, 0)));

// Draw polar graph
function drawPolarGraph(theta,r){
    thetaCtx.clearRect(0,0,thetaCanvas.width,thetaCanvas.height);
    const cx = thetaCanvas.width/2;
    const cy = thetaCanvas.height/2;

    // Draw axes
    thetaCtx.strokeStyle = "white";
    thetaCtx.beginPath();
    thetaCtx.moveTo(cx,0); thetaCtx.lineTo(cx,thetaCanvas.height);
    thetaCtx.moveTo(0,cy); thetaCtx.lineTo(thetaCanvas.width,cy);
    thetaCtx.stroke();

    // Draw radial line at theta
    const maxR = 1.5e11;
    const len = (r>maxR)? maxR : r;
    const scale = (thetaCanvas.width/2)/maxR;
    const x = cx + len*scale*Math.cos(theta);
    const y = cy - len*scale*Math.sin(theta);

    thetaCtx.strokeStyle = "red";
    thetaCtx.beginPath();
    thetaCtx.moveTo(cx,cy);
    thetaCtx.lineTo(x,y);
    thetaCtx.stroke();

    // Update theta value display
    const deg = (theta<0?theta+2*Math.PI:theta)*(180/Math.PI);
    thetaValueDiv.innerText = `Theta Value: ${ (theta<0?theta+2*Math.PI:theta).toFixed(3) } rad | ${deg.toFixed(1)}°`;
}

// Animation
const TIME_SCALE = .01*24*3600;
let lastTime = performance.now();
controls.minDistance =10;   // how close camera can zoom in
controls.maxDistance = 1000; 
function animate(){
    const now = performance.now();
    const dt = (now-lastTime)/1000*TIME_SCALE;
    lastTime = now;

    if(orbitPoints.length>0){
        const orbit=computeOrbit(original.M*parseFloat(sliders.M.value),
                                 original.m*parseFloat(sliders.m.value),
                                 original.G,
                                 original.rmin*parseFloat(sliders.rmin.value),
                                 original.vo*parseFloat(sliders.vo.value));

        if(orbit.e<1){ orbitTheta+=dt*0.00001; if(orbitTheta>=1) orbitTheta=0; }
        else{ if(orbitTheta<1) orbitTheta+=dt*0.00001; }

        if(orbitTheta<1){
            const idx=Math.floor(orbitTheta*orbitPoints.length);
            const pos=orbitPoints[idx];
            earth.position.set(pos.x,pos.y,pos.z);

            const rVec=new THREE.Vector3(pos.x,0,pos.z);
            const tangDir=new THREE.Vector3(-pos.z,0,pos.x).normalize();
            const vMag=orbit.h/(rVec.length()/SCALE_FACTOR);
            velocityArrow.position.set(pos.x,pos.y,pos.z);
            velocityArrow.setDirection(tangDir);
            velocityArrow.setLength(2);
            paramLabels.vel.innerText=vMag.toExponential(3);

            const theta = Math.atan2(pos.z,pos.x);
            const r = rVec.length()/SCALE_FACTOR;
            drawPolarGraph(theta,r);
        }
    }
  spheres.forEach((particleSystem) => {
    particleSystem.rotation.y += 0.001;
  });

    controls.update();
    renderer.render(scene,camera);
    requestAnimationFrame(animate);
}

updateOrbit();
animate();

window.addEventListener("resize",()=>{
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth,window.innerHeight);
});
</script>
</body>
</html> -->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Orbit Simulation with Polar Graph and Theta</title>
<style>
    body {
        margin: 0;
        overflow: hidden;
        background: black;
        color: #fff;
        font-family: sans-serif;
    }

    #controls {
        position: absolute;
        top: 20px;
        left: 20px;
        width: 300px;
        background: rgba(255, 255, 255, 0.05); /* very subtle transparent bg */
        padding: 15px;
        border-radius: 12px;
        border: 1px solid rgba(255,255,255,0.2);
        backdrop-filter: blur(5px); /* subtle blur behind */
        box-shadow: 0 8px 20px rgba(0,0,0,0.3);
    }

    #controls label {
        display: block;
        margin-top: 12px;
        font-size: 16px;
    }

    #controls input[type=range] {
        width: 100%;
        height: 16px;
        margin-top: 4px;
        accent-color: #00ffff;
    }

    #params {
        margin-top: 15px;
        font-size: 14px;
        line-height: 1.5;
        padding: 8px;
        background: rgba(255,255,255,0.05);
        border-radius: 8px;
        border: 1px solid rgba(255,255,255,0.15);
    }

    #thetaGraph {
        width: 100%;
        height: 200px;
        border: 1px solid #00ffff;
        margin-top: 15px;
        display: block;
        border-radius: 8px;
        background: rgba(255,255,255,0.05);
    }

    #thetaValue {
        margin-top: 8px;
        font-size: 14px;
        text-align: center;
        color: #00ffff;
    }

    /* Optional: nice scrollbar for the panel if needed */
    #controls::-webkit-scrollbar {
        width: 6px;
    }
    #controls::-webkit-scrollbar-thumb {
        background-color: rgba(0,255,255,0.5);
        border-radius: 3px;
    }

    #messageOverlay {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 4em;
        color: red;
        font-weight: bold;
        text-shadow: 0 0 10px rgba(255, 0, 0, 0.8), 0 0 20px rgba(255, 0, 0, 0.6);
        display: none; /* Hidden by default */
        z-index: 1000;
    }

    #orbitalChangeMessage { /* New element for orbital change message */
        position: absolute;
        top: 80px; /* Positioned below controls */
        left: 50%;
        transform: translateX(-50%);
        font-size: 1.5em;
        color: #00ffff;
        text-shadow: 0 0 5px rgba(0, 255, 255, 0.8);
        background: rgba(0,0,0,0.7);
        padding: 8px 15px;
        border-radius: 8px;
        border: 1px solid rgba(0,255,255,0.5);
        display: none; /* Hidden by default */
        z-index: 999;
    }
</style>

</head>
<body>
<div id="controls">
    <label>Sun Mass (M) <span id="Mval"></span>
        <input type="range" id="Mslider" min="0" max="6" step="0.01" value="1">
    </label>
    <label>Earth Mass (m) <span id="mval"></span>
        <input type="range" id="mslider" min="0" max="6" step="0.01" value="1">
    </label>
    <label>Perihelion (rmin) <span id="rval"></span>
        <input type="range" id="rslider" min="0" max="6" step="0.01" value="1">
    </label>
    <label>Velocity (vo) <span id="vval"></span>
        <input type="range" id="vslider" min="0" max="6" step="0.01" value="1">
    </label>
    <div id="params">
        <strong>Orbit Parameters:</strong><br>
        e = <span id="eval"></span><br>
        a = <span id="aval"></span><br>
        b = <span id="bval"></span><br>
        h = <span id="hval"></span><br>
        ε = <span id="epsval"></span><br>
        Tangential Velocity = <span id="velval"></span> m/s<br>
        Orbital Period = <span id="periodval"></span> years<br>
        Theta (θ) = <span id="thetaval"></span>
    </div>
    <canvas id="thetaGraph" width="300" height="300"></canvas>
    <div id="thetaValue">Theta Value: 0 rad | 0°</div>
</div>

<div id="messageOverlay"></div>
<div id="orbitalChangeMessage"></div> <!-- New message div for orbital changes -->

<script type="module">
import * as THREE from "https://cdn.skypack.dev/three@0.129.0";
import { OrbitControls } from "https://cdn.skypack.dev/three@0.129.0/examples/jsm/controls/OrbitControls.js";
import { CSS2DRenderer, CSS2DObject } from "https://cdn.skypack.dev/three@0.129.0/examples/jsm/renderers/CSS2DRenderer.js";
import { EffectComposer } from 'https://cdn.skypack.dev/three@0.129.0/examples/jsm/postprocessing/EffectComposer.js';
import { RenderPass } from 'https://cdn.skypack.dev/three@0.129.0/examples/jsm/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'https://cdn.skypack.dev/three@0.129.0/examples/jsm/postprocessing/UnrealBloomPass.js';

// === Three.js Scene ===
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(85, window.innerWidth/window.innerHeight, 0.1, 10000);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.05;
camera.position.z = 30;

// Constants
const original = {
    M: 1.98847e30,
    m: 5.97237e24,
    rmin: 1.47095e11,
    vo: 3.029195106e4,
    G: 6.67430e-11
};
const SCALE_FACTOR = 1e-10;

// DOM Elements - direct references to sliders
const Mslider = document.getElementById("Mslider");
const mslider = document.getElementById("mslider");
const rslider = document.getElementById("rslider");
const vslider = document.getElementById("vslider");

const sliders = { M: Mslider, m: mslider, rmin: rslider, vo: vslider };

const labels = { M: document.getElementById("Mval"), m: document.getElementById("mval"),
                 rmin: document.getElementById("rval"), vo: document.getElementById("vval") };
const paramLabels = { e: document.getElementById("eval"), a: document.getElementById("aval"),
                      b: document.getElementById("bval"), h: document.getElementById("hval"),
                      eps: document.getElementById("epsval"), vel: document.getElementById("velval"),
                      period: document.getElementById("periodval"), theta: document.getElementById("thetaval") };
const thetaValueDiv = document.getElementById("thetaValue");
const messageOverlay = document.getElementById("messageOverlay");
const orbitalChangeMessage = document.getElementById("orbitalChangeMessage"); // New orbital change message div

for (let key in sliders) {
    labels[key].innerText = sliders[key].value;
    sliders[key].addEventListener("input", () => {
        labels[key].innerText = sliders[key].value;
        updateOrbit(true); // Pass true to indicate user input
    });
}

// Canvas for theta graph
const thetaCanvas = document.getElementById("thetaGraph");
const thetaCtx = thetaCanvas.getContext("2d");

// Sun
const textureLoader1 = new THREE.TextureLoader();
const fireTexture = textureLoader1.load('./sun.jpg'); // Ensure you have this image
fireTexture.wrapS = fireTexture.wrapT = THREE.RepeatWrapping;
// Sun Material
const sunMaterial = new THREE.MeshStandardMaterial({
  map: fireTexture,
  emissive: new THREE.Color(0xffaa00),
  emissiveMap: fireTexture,
  emissiveIntensity: 2
});
// Sun Mesh
const sunGeometry = new THREE.SphereGeometry(2, 18, 18); // Sun's visual radius is 2
const sun = new THREE.Mesh(sunGeometry, sunMaterial);
scene.add(sun);
const sunLight = new THREE.PointLight(0xffddaa, 10, 1000);
sunLight.position.copy(sun.position);
scene.add(sunLight);
const composer = new EffectComposer(renderer);
composer.addPass(new RenderPass(scene, camera));
composer.addPass(new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85));
 // Texture Loader
  const loader = new THREE.TextureLoader();
  const planetTexture = loader.load("./earth_day_4096.jpg"); // Ensure you have this image

  // Planet Material & Mesh
  const planetMaterial = new THREE.MeshPhongMaterial({
    map: planetTexture,
          bumpMap: planetTexture,
  bumpScale: 0.05,
  roughness: 1,
  metalness: 0
    
  });
// Earth
const earth1 = new THREE.SphereGeometry(0.5,32,32); // Earth's visual radius is 0.5
const earth = new THREE.Mesh(earth1,planetMaterial);
scene.add(earth);

// Velocity Arrow
const velocityArrow = new THREE.ArrowHelper(new THREE.Vector3(1,0,0), new THREE.Vector3(0,0,0), 2, 0xff0000);
scene.add(velocityArrow);

let orbitLine = null;
let orbitPoints = [];
let orbitTheta = 0;

// Store previous orbit type for comparison (re-introduced)
let previousOrbitType = null; // 'ellipse', 'parabola', 'hyperbola'
let orbitalChangeMessageTimeout = null; // To clear previous timeouts

function getOrbitType(e) {
    if (e < 1 - Number.EPSILON) return 'ellipse'; // Use a small epsilon for floating point comparison
    if (Math.abs(e - 1) < Number.EPSILON) return 'parabola';
    return 'hyperbola';
}


// Orbit calculations
function computeOrbit(M, m, G, rmin, vo){
    const h = rmin * vo;
    const eps = 0.5 * vo * vo - (G * M) / rmin;
    const e = Math.sqrt(1 + (2 * eps * h*h)/(G*M*G*M));
    let a = (e<1)? -(G*M)/(2*eps) : Math.abs(G*M/(2*eps));
    if(e===1) a=h*h/(G*M);
    return {h, eps, e, a};
}

function createOrbit(a,e,numPoints=500){
    const points = [];
    if(e<1){
        const centerX=-a*e;
        const b=a*Math.sqrt(1-e*e);
        for(let i=0;i<=numPoints;i++){
            const theta=i/numPoints*2*Math.PI;
            const x=centerX+a*Math.cos(theta);
            const z=b*Math.sin(theta);
            points.push(new THREE.Vector3(x*SCALE_FACTOR,0,z*SCALE_FACTOR));
        }
    }else{
        const thetaMax = (e>=1)? Math.acos(-1/e)*0.95 : Math.PI*0.95;
        for(let i=0;i<=numPoints;i++){
            const theta=i/numPoints*2*thetaMax - thetaMax;
            const r = (e===1)? a/(1+e*Math.cos(theta)) : a*(e*e-1)/(1+e*Math.cos(theta));
            if(r>0){
                points.push(new THREE.Vector3(r*Math.cos(theta)*SCALE_FACTOR,0,r*Math.sin(theta)*SCALE_FACTOR));
            }
        }
    }
    return points;
}

function updateOrbit(fromUserInput = false){
    if(orbitLine) scene.remove(orbitLine);
    const Mval=original.M*parseFloat(Mslider.value); // Use direct slider value
    const mval=original.m*parseFloat(mslider.value); // Use direct slider value
    const rval=original.rmin*parseFloat(rslider.value); // Use direct slider value
    const vval=original.vo*parseFloat(vslider.value); // Use direct slider value
    const orbit=computeOrbit(Mval,mval,original.G,rval,vval);

    let b=(orbit.e<1)? orbit.a*Math.sqrt(1-orbit.e*orbit.e) :
          (orbit.e>1)? orbit.a*Math.sqrt(orbit.e*orbit.e-1) : orbit.a;

    // Orbital period in years
    let period="Infinity";
    if(orbit.e<1){
        period = (2*Math.PI*Math.sqrt(Math.pow(orbit.a,3)/(original.G*Mval)))/(60*60*24*365.25);
        period = period.toFixed(3);
    }

    paramLabels.e.innerText=orbit.e.toFixed(5);
    paramLabels.a.innerText=orbit.a.toExponential(5);
    paramLabels.b.innerText=(typeof b==="number")? b.toExponential(5) : b;
    paramLabels.h.innerText=orbit.h.toExponential(5);
    paramLabels.eps.innerText=orbit.eps.toExponential(5);
    paramLabels.period.innerText=period;

    orbitPoints=createOrbit(orbit.a,orbit.e,500);
    orbitLine=new THREE.Line(new THREE.BufferGeometry().setFromPoints(orbitPoints),
                             new THREE.LineBasicMaterial({color:0x00FFFF}));
    scene.add(orbitLine);
    orbitTheta=0;

    // *** Re-introducing orbit type change detection, separate from collision ***
    const currentOrbitType = getOrbitType(orbit.e);
    if (fromUserInput && previousOrbitType && currentOrbitType !== previousOrbitType) {
        // Clear any existing timeout for the orbital change message
        if (orbitalChangeMessageTimeout) {
            clearTimeout(orbitalChangeMessageTimeout);
        }
        orbitalChangeMessage.innerText = `ORBIT TYPE CHANGED TO ${currentOrbitType.toUpperCase()}!`;
        orbitalChangeMessage.style.display = 'block';
        // Set a timeout to hide the message after 4 seconds
        orbitalChangeMessageTimeout = setTimeout(() => {
            orbitalChangeMessage.style.display = 'none';
        }, PAUSE_DURATION); // Use the same duration for consistency
    }
    previousOrbitType = currentOrbitType; // Update previous orbit type

    // Reset collision state when orbit updates (only if not already in a collision pause)
    if (simulationState !== 'collision') {
        earth.visible = true;
        messageOverlay.style.display = 'none'; // Ensure collision message is hidden
        velocityArrow.visible = true;
        simulationState = 'running'; // Ensure state is reset to running
    }
}
// / Light
const pointLight = new THREE.PointLight(0xffffff, 2, 2000);
pointLight.position.set(50, 50, 50);
scene.add(pointLight);
scene.add(new THREE.AmbientLight(0x333333));

// ------------ Function: Create Sphere with Surface Particles ------------
function createSphereWithParticles(radius, numParticles, opacity, color, position) {
  const particlesGeometry = new THREE.BufferGeometry();
  const positions = [];

  for (let i = 0; i < numParticles; i++) {
    // Random direction on a sphere (normalized vector)
    const theta = Math.random() * Math.PI * 2;  // azimuth
    const phi = Math.acos(2 * Math.random() - 1); // polar angle
    const x = radius * Math.sin(phi) * Math.cos(theta);
    const y = radius * Math.sin(phi) * Math.sin(theta);
    const z = radius * Math.cos(phi);
    positions.push(x, y, z);
  }

  particlesGeometry.setAttribute(
    "position",
    new THREE.Float32BufferAttribute(positions, 3)
  );

  const particlesMaterial = new THREE.PointsMaterial({
    color: color,
    size: 0.3,
    transparent: true,
    opacity: opacity,
    blending: THREE.AdditiveBlending
  });

  const particleSystem = new THREE.Points(particlesGeometry, particlesMaterial);
  particleSystem.position.copy(position);
  scene.add(particleSystem);

  return particleSystem;
}

// ------------ Create Multiple Spheres with Particles ------------
const spheres = [];
spheres.push(createSphereWithParticles(109000, 1000, 0.8, 0xff0f00, new THREE.Vector3(-50, 0, 0)));
spheres.push(createSphereWithParticles(107000, 1000, 0.8, 0xf00f00, new THREE.Vector3(-50, 0, 0)));
spheres.push(createSphereWithParticles(6000, 1000, 0.8, 0xefff00, new THREE.Vector3(-50, 0, 0)));
spheres.push(createSphereWithParticles(10500, 1000, 0.8, 0xfeef00, new THREE.Vector3(-50, 0, 0)));
spheres.push(createSphereWithParticles(100000, 1000, 0.8, 0xffef00, new THREE.Vector3(-50, 0, 0)));
spheres.push(createSphereWithParticles(100300, 1000, 0.8, 0xff0000, new THREE.Vector3(-50, 0, 0)));

// Draw polar graph
function drawPolarGraph(theta,r){
    thetaCtx.clearRect(0,0,thetaCanvas.width,thetaCanvas.height);
    const cx = thetaCanvas.width/2;
    const cy = thetaCanvas.height/2;

    // Draw axes
    thetaCtx.strokeStyle = "white";
    thetaCtx.beginPath();
    thetaCtx.moveTo(cx,0); thetaCtx.lineTo(cx,thetaCanvas.height);
    thetaCtx.moveTo(0,cy); thetaCtx.lineTo(thetaCanvas.width,cy);
    thetaCtx.stroke();

    // Draw radial line at theta
    const maxR = 1.5e11; // This is a maximum real-world distance for scaling the graph
    const len = (r>maxR)? maxR : r;
    const scale = (thetaCanvas.width/2)/maxR;
    const x = cx + len*scale*Math.cos(theta);
    const y = cy - len*scale*Math.sin(theta);

    thetaCtx.strokeStyle = "red";
    thetaCtx.beginPath();
    thetaCtx.moveTo(cx,cy);
    thetaCtx.lineTo(x,y);
    thetaCtx.stroke();

    // Update theta value display
    const deg = (theta<0?theta+2*Math.PI:theta)*(180/Math.PI);
    thetaValueDiv.innerText = `Theta Value: ${ (theta<0?theta+2*Math.PI:theta).toFixed(3) } rad | ${deg.toFixed(1)}°`;
}

// Animation
const TIME_SCALE = .01*24*3600;
let lastTime = performance.now();
controls.minDistance =10;   // how close camera can zoom in
controls.maxDistance = 1000;

// Define visual radii for collision detection in Three.js units
const sunVisualRadius = 2;
const earthVisualRadius = 0.5;
const collisionDistanceThreshold = sunVisualRadius + earthVisualRadius; // When they "touch" visually

// New state variables for collision and pause
let simulationState = 'running'; // 'running', 'collision', 'reset'
let pauseStartTime = 0; // Use a single pause start time for collision
const PAUSE_DURATION = 4000; // 4 seconds in milliseconds for both collision and orbital change message

function animate(){
    const now = performance.now();
    const dt = (now-lastTime)/1000*TIME_SCALE;
    lastTime = now;

    if (simulationState === 'reset') {
        // Reset slider values to 1
        Mslider.value = "1";
        mslider.value = "1";
        rslider.value = "1";
        vslider.value = "1";

        // Update slider labels
        labels.M.innerText = Mslider.value;
        labels.m.innerText = mslider.value;
        labels.rmin.innerText = rslider.value;
        labels.vo.innerText = vslider.value;

        updateOrbit(); // Recalculate orbit with new slider values
    }

    if (simulationState === 'running' && orbitPoints.length > 0) {
        // Recalculate orbit for the current frame, but only update the visual path if the sliders haven't changed
        // This is important because orbitTheta advances based on the *current* orbit,
        // but `updateOrbit()` is only called on slider change or reset.
        const orbit=computeOrbit(original.M*parseFloat(Mslider.value),
                                 original.m*parseFloat(mslider.value),
                                 original.G,
                                 original.rmin*parseFloat(rslider.value),
                                 original.vo*parseFloat(vslider.value));

        if(orbit.e<1){ orbitTheta+=dt*0.00001; if(orbitTheta>=1) orbitTheta=0; }
        else{ if(orbitTheta<1) orbitTheta+=dt*0.00001; }

        if(orbitTheta<1){
            const idx=Math.floor(orbitTheta*orbitPoints.length);
            const pos=orbitPoints[idx];
            earth.position.set(pos.x,pos.y,pos.z);

            // Collision Detection
            const distanceBetweenBodies = sun.position.distanceTo(earth.position);

            if (distanceBetweenBodies <= collisionDistanceThreshold) {
                messageOverlay.innerText = "SUN AND EARTH HIT!";
                simulationState = 'collision'; // Set state to collision
                pauseStartTime = now; // Record collision time

                earth.visible = false; // Hide Earth
                messageOverlay.style.display = 'block'; // Show collision message
                velocityArrow.visible = false; // Hide velocity arrow
                // No further orbit updates in this frame
            } else {
                // Normal running state: ensure everything is visible and updated
                earth.visible = true;
                messageOverlay.style.display = 'none'; // Ensure collision message is hidden
                velocityArrow.visible = true;

                const rVec=new THREE.Vector3(pos.x,0,pos.z);
                const tangDir=new THREE.Vector3(-pos.z,0,pos.x).normalize();
                const vMag=orbit.h/(rVec.length()/SCALE_FACTOR);
                velocityArrow.position.set(pos.x,pos.y,pos.z);
                velocityArrow.setDirection(tangDir);
                velocityArrow.setLength(2);
                paramLabels.vel.innerText=vMag.toExponential(3);

                const theta = Math.atan2(pos.z,pos.x);
                const r = rVec.length()/SCALE_FACTOR;
                drawPolarGraph(theta,r);
            }
        }
    } else if (simulationState === 'collision') {
        // Check if pause duration has passed for collision
        if (now - pauseStartTime >= PAUSE_DURATION) {
            simulationState = 'reset'; // Trigger reset
        }
        // Keep earth hidden, collision message shown, velocity arrow hidden during collision pause
        earth.visible = false;
        messageOverlay.style.display = 'block';
        velocityArrow.visible = false;
    }
    // Particle spheres always animate regardless of main simulation state
    spheres.forEach((particleSystem) => {
        particleSystem.rotation.y += 0.001;
    });

    controls.update();
    composer.render(); // Use composer.render() for bloom effect
    requestAnimationFrame(animate);
}

updateOrbit(); // Initial call
animate();

window.addEventListener("resize",()=>{
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth,window.innerHeight);
    composer.setSize(window.innerWidth, window.innerHeight); // Update composer size too
});
</script>
</body>
</html>